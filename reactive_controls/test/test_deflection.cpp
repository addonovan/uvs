#include <cstdio>

#include <gtest/gtest.h>

#include <units.hpp>
#include <deflection.hpp>

double get_angle(double min, double step, int i);

TEST(TestDeflection, convertAngle) {
    // generated by the outputs of the function
    ASSERT_FLOAT_EQ(get_angle(0.0, PI / 180.0, 0  ), +3.141600000000000);
    ASSERT_FLOAT_EQ(get_angle(0.0, PI / 180.0, 45 ), +2.356201836602552);
    ASSERT_FLOAT_EQ(get_angle(0.0, PI / 180.0, 90 ), +1.570803673205103);
    ASSERT_FLOAT_EQ(get_angle(0.0, PI / 180.0, 135), +0.785405509807656);
    ASSERT_FLOAT_EQ(get_angle(0.0, PI / 180.0, 180), +0.000007346410206);
    ASSERT_FLOAT_EQ(get_angle(0.0, PI / 180.0, 225), -0.785390816987241);
    ASSERT_FLOAT_EQ(get_angle(0.0, PI / 180.0, 270), -1.570788980384690);
    ASSERT_FLOAT_EQ(get_angle(0.0, PI / 180.0, 315), -2.356187143782138);
}

TEST(TestDeflection, infiniteReadingsInvalid) {
    ASSERT_FALSE(is_valid_reading(0.0, 100.0,  1.0 / 0.0, 0.0));
    ASSERT_FALSE(is_valid_reading(0.0, 100.0, -1.0 / 0.0, 0.0));
    ASSERT_FALSE(is_valid_reading(0.0, 100.0,  0.0 / 0.0, 0.0));
}

TEST(TestDeflection, readingsWithinRange) {
    ASSERT_FALSE(is_valid_reading(0.0, 100.0,   -1.0, 0.0));
    ASSERT_FALSE(is_valid_reading(0.0, 100.0, 1000.0, 0.0));

    ASSERT_TRUE(is_valid_reading(0.0, 100.0, 75.0, 0.0));
    ASSERT_TRUE(is_valid_reading(0.0, 100.0, 50.0, 0.0));
    ASSERT_TRUE(is_valid_reading(0.0, 100.0, 25.0, 0.0));
}

TEST(TestDeflection, readingsWithinAngleRange) {
    ASSERT_FALSE(is_valid_reading(0.0, 100.0, 50.0, -PI));
    ASSERT_FALSE(is_valid_reading(0.0, 100.0, 50.0, -(PI / 2) - 0.05));

    ASSERT_TRUE(is_valid_reading(0.0, 100.0, 50.0, -(PI / 2) + 0.05));
    ASSERT_TRUE(is_valid_reading(0.0, 100.0, 50.0, -(PI / 4)));
    ASSERT_TRUE(is_valid_reading(0.0, 100.0, 50.0,  0));
    ASSERT_TRUE(is_valid_reading(0.0, 100.0, 50.0,  (PI / 4)));
    ASSERT_TRUE(is_valid_reading(0.0, 100.0, 50.0,  (PI / 2) - 0.05));

    ASSERT_FALSE(is_valid_reading(0.0, 100.0, 50.0,  PI));
    ASSERT_FALSE(is_valid_reading(0.0, 100.0, 50.0,  (PI / 2) + 0.05));

}

TEST(TestDeflection, findsSmallestReading) {
    double angle_min = 0.0;
    double angle_step = PI / 4;
    double range_min = 0.0;
    double range_max = 1.0 / 0.0;

    // supplied distances in [m], values returned in [cm]
    auto entries = std::vector<float>{{
        250.0f,         // 0
        1 / 0.0f,       // PI / 4
        125.0f,         // PI / 2
        50.0f           // 3PI / 4
    }};

    auto reading = find_min_reading(
        angle_min, angle_step,
        range_min, range_max,
        entries
    );
    ASSERT_FLOAT_EQ(reading.range, 5000.0);
    ASSERT_FLOAT_EQ(reading.angle, get_angle(angle_min, angle_step, 3));

    // no valid numbers in forward direction
    reading = find_min_reading(
        angle_min, angle_step,
        100.0, range_max,
        entries
    );
    ASSERT_TRUE(std::isinf(reading.range));
}
